<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>窗外临街</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="窗外临街">
<meta property="og:url" content="http://peihao.space/index.html">
<meta property="og:site_name" content="窗外临街">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="窗外临街">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="窗外临街" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xowaa.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">培豪</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/album">相册</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/chuangwailinjie" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/chuangwailinjie" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/peihaozhu" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Front-End/" style="font-size: 20px;">Front End</a> <a href="/tags/基础知识/" style="font-size: 10px;">基础知识</a> <a href="/tags/随笔/" style="font-size: 20px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">衣服晒干风在穿，我一个人，很简单，自己放纵自己管…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">培豪</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xowaa.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">培豪</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/album">相册</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/chuangwailinjie" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/chuangwailinjie" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/peihaozhu" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-JQuery选择器、过滤器介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/JQuery选择器、过滤器介绍/" class="article-date">
  	<time datetime="2015-12-05T15:25:16.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/JQuery选择器、过滤器介绍/">JQuery选择器、过滤器介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、JQuery对象与DOM对象">一、JQuery对象与DOM对象</h2><p>1.JQuery对象<br>JQuery对象就是使用“$(“DOMObj”)”，将DOM对象包装起来。一般在JQuery对象前面加上“$”这样与DMO对象区分，它已经是一种公认的命名约定。JQuery对象不能调用DOM对象的属性和方法，同样DOM对象也不能调用JQuery对象的属性和方法。 </p>
<p>2.JQuery对象转成DOM对象<br>如果想使用JQuery对象调用DOM对象的方法，怎么办？应该将JQuery对象转换成DOM对象，JQuery对象是一个数组对象，这个很特别。所以只需调用JQueryObj[x]或JQueryObj.get(X);即可转换为DOM对象。 </p>
<p>3.DOM对象转换成JQuery对象<br>使用“$(“DOMObj”)”将DOM对象包装起来就可以了。 </p>
<h2 id="二、JQuery选择器">二、JQuery选择器 </h2><p>选择器是JQuery的根基，在JQuery 中，对事件处理，遍历DOM和Ajax操作都依赖于选择器。这也是今天我们学习的重点内容。 </p>
<p>1.基本选择器<br>基本选择器是JQuery中最常用的选择器，也是最简单的选择器，它通过元素id、class 和标签名来查找DOM元素。这个非常重要，下面的内容都是以此为基础，逐级提高的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>).“$(“<span class="preprocessor">#id”)”，<span class="comment">//获取id指定的元素，id是全局唯一的，所以它只有一个成员。 </span></span></span><br><span class="line"><span class="number">2</span>).“$(“.<span class="keyword">class</span>”)”，<span class="comment">//获取class指定的元素，不同的元素可以具有相同的class属性，所以它可能具有多个成员。 </span></span><br><span class="line"><span class="number">3</span>).“$(“element”)”，<span class="comment">//获取element（元素名，比如div、table等）指定的元素，它可能具有多个成员。 </span></span><br><span class="line"><span class="number">4</span>).“$(“*”)”，<span class="comment">//获取所有元素，相当于document。 </span></span><br><span class="line"><span class="number">5</span>).“$(“selector1,selector2,…,selectorN”)”，<span class="comment">//将每个选择器匹配到的元素合并后一起返回。返回selector1匹配的集合+selector2匹配的集合+…+selectorN匹配的集合。</span></span><br></pre></td></tr></table></figure>
<p>2.层次选择器<br>什么是层次？层次就是父子关系、兄弟关系的节点。所以，层次选择器就是用来获取指定元素的父子节点、兄弟节点。 </p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>).“<span class="variable">$(</span>“ancestor descendant”)”，获取ancestor元素下边的所有元素。 </span><br><span class="line"><span class="number">2</span>).“<span class="variable">$(</span>“<span class="keyword">parent</span> &gt; child”)”，获取<span class="keyword">parent</span>元素下边的所有子元素（只包含第一层子元素）。 </span><br><span class="line"><span class="number">3</span>).“<span class="variable">$(</span>“pre + next”)”，获取紧随pre元素的后一个兄弟元素。 </span><br><span class="line"><span class="number">4</span>).“<span class="variable">$(</span>“pre ~ siblings”)”，获取pre元素后边的所有兄弟元素。</span><br></pre></td></tr></table></figure>
<p>3.过滤选择器<br>过滤？肯定是要添加过滤条件的。通过“:”添加过滤条件，比如“$(“div:first”)”返回div元素集合的第一个div元素，first是过滤条件。<br>按照不同的过滤规则，过滤选择器可以分为基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器。 </p>
<p>1). 基本过滤选择器   </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a) “:first”，选取第一个元素，别忘记它也是被放在一个集合里哦！因为JQuery它是DOM对象的一个集合。如，“<span class="variable">$(</span><span class="string">"tr:first"</span>)”返回所有<span class="keyword">tr</span>元素的第一个<span class="keyword">tr</span>元素，它仍然被保存在集合中。 </span><br><span class="line">b) “:<span class="keyword">last</span>”，选取最后一个元素。如，“<span class="variable">$(</span><span class="string">"tr:last"</span>)”返回所有<span class="keyword">tr</span>元素的最后一个<span class="keyword">tr</span>元素，它仍然被保存在集合中。 </span><br><span class="line">c) “:<span class="keyword">not</span>(selector)”，去除所有与给定选择器匹配的元素。如，“<span class="variable">$(</span><span class="string">"input:not(:checked)"</span>)”返回所有input元素，但去除被选中的元素（单选框、多选框）。 </span><br><span class="line">d) “:even”，选取所有元素中偶数的元素。因为JQuery对象是一个集合，这里的偶数指的就是集合的索引，索引从<span class="number">0</span>开始。 </span><br><span class="line">e) “:odd”，选取所有元素中奇数的元素，索引从<span class="number">0</span>开始。 </span><br><span class="line">f) “:e<span class="string">q(index)</span>”，选取指定索引的元素，索引从<span class="number">0</span>开始。 </span><br><span class="line">g) “:<span class="keyword">gt</span>(<span class="keyword">index</span>)”，选取索引大于指定<span class="keyword">index</span>的元素，索引从<span class="number">0</span>开始。 </span><br><span class="line">h) “:<span class="keyword">lt</span>(<span class="keyword">index</span>)”，选取索引小于指定<span class="keyword">index</span>的元素，索引从<span class="number">0</span>开始。 </span><br><span class="line">i) “:header”，选取所有的标题元素，如hq、h2等。 </span><br><span class="line">j) “:animated”，选取当前正在执行的所有动画元素。</span><br></pre></td></tr></table></figure>
<p>2). 内容过滤选择器<br>它是对元素和文本内容的操作。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a) “:<span class="function"><span class="title">contains</span><span class="params">(text)</span></span>”，选取包含text文本内容的元素。 </span><br><span class="line">b) “:empty”，选取不包含子元素或者文本节点的空元素。 </span><br><span class="line">c) “:<span class="function"><span class="title">has</span><span class="params">(selector)</span></span>”，选取含有选择器所匹配的元素的元素。 </span><br><span class="line">d) “:parent”，选取含有子元素或文本节点的元素。（它是一个父节点）</span><br></pre></td></tr></table></figure>
<p>3). 可见性过滤选择器<br>根据元素的可见与不可见状态来选取元素。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“<span class="pseudo">:hidden</span>”，选取所有不可见元素。 </span><br><span class="line">“<span class="pseudo">:visible</span>”，选择所有可见元素。 </span><br><span class="line">可见选择器：<span class="tag">hidden</span> 不仅包含样式属性 <span class="tag">display</span> 为 <span class="tag">none</span> 的元素，也包含文本隐藏域 </span><br><span class="line">	(&lt;input type=“hidden”&gt;)</span><br><span class="line">和 <span class="tag">visible</span><span class="pseudo">:hidden</span> 之类的元素。</span><br></pre></td></tr></table></figure>
<p>4).属性过滤选择器<br>通过元素的属性来选取相应的元素。 </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a) “[<span class="literal">attribute</span>]”，选取拥有此属性的元素。 </span><br><span class="line">b) “[<span class="literal">attribute</span>=<span class="keyword">value</span>]”，选取指定属性值为<span class="keyword">value</span>的所有元素。 </span><br><span class="line">c) “[<span class="literal">attribute</span> !=<span class="keyword">value</span>]”，选取属性值不为<span class="keyword">value</span>的所有元素。 </span><br><span class="line">d) “[<span class="literal">attribute</span> ^= <span class="keyword">value</span>]”，选取属性值以<span class="keyword">value</span>开始的所有元素。 </span><br><span class="line">e) “[<span class="literal">attribute</span> $= <span class="keyword">value</span>]”，选取属性值以<span class="keyword">value</span>结束的所有元素。 </span><br><span class="line">f) “[<span class="literal">attribute</span> *= <span class="keyword">value</span>]”，选取属性值包含<span class="keyword">value</span>的所有元素。 </span><br><span class="line">g) “[selector1] [selector2]…[selectorN]”，复合性选择器，首先经[selector1]选择返回集合A，集合A再经过[selector2]选择返回集合B，集合B再经过[selectorN]选择返回结果集合。</span><br></pre></td></tr></table></figure>
<p>5). 子元素过滤选择器<br>一看名字便是，它是对某一元素的子元素进行选取的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a) “:<span class="function"><span class="title">nth-child</span><span class="params">(index/even/odd)</span></span>”，选取索引为index的元素、索引为偶数的元素、索引为奇数的元素。 </span><br><span class="line">l <span class="function"><span class="title">nth-child</span><span class="params">(even/odd)</span></span>：能选取每个父元素下的索引值为偶(奇)数的元素。 </span><br><span class="line">l <span class="function"><span class="title">nth-child</span><span class="params">(<span class="number">2</span>)</span></span>：能选取每个父元素下的索引值为 <span class="number">2</span> 的元素。 </span><br><span class="line">l <span class="function"><span class="title">nth-child</span><span class="params">(<span class="number">3</span>n)</span></span>：能选取每个父元素下的索引值是 <span class="number">3</span> 的倍数的元素。 </span><br><span class="line">l <span class="function"><span class="title">nth-child</span><span class="params">(<span class="number">3</span>n + <span class="number">1</span>)</span></span>：能选取每个父元素下的索引值是 <span class="number">3</span>n + <span class="number">1</span>的元素。 </span><br><span class="line">b) “:first-child”，选取第一个子元素。 </span><br><span class="line">c) “:last-child”，选取最后一个子元素。 </span><br><span class="line">d) “:only-child”，选取唯一子元素，它的父元素只有它这一个子元素。</span><br></pre></td></tr></table></figure>
<p>6). 表单过滤选择器<br>选取表单元素的过滤选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span>) “<span class="pseudo">:input</span>”，选取所有&lt;<span class="tag">input</span>&gt;、&lt;<span class="tag">textarea</span>&gt;、&lt;<span class="tag">select</span> &gt;和&lt;<span class="tag">button</span>&gt;元素。 </span><br><span class="line"><span class="tag">b</span>) “<span class="pseudo">:text</span>”，选取所有的文本框元素。 </span><br><span class="line"><span class="tag">c</span>) “<span class="pseudo">:password</span>”，选取所有的密码框元素。 </span><br><span class="line"><span class="tag">d</span>) “<span class="pseudo">:radio</span>”，选取所有的单选框元素。 </span><br><span class="line"><span class="tag">e</span>) “<span class="pseudo">:checkbox</span>”，选取所有的多选框元素。 </span><br><span class="line"><span class="tag">f</span>) “<span class="pseudo">:submit</span>”，选取所有的提交按钮元素。 </span><br><span class="line"><span class="tag">g</span>) “<span class="pseudo">:image</span>”，选取所有的图像按钮元素。 </span><br><span class="line"><span class="tag">h</span>) “<span class="pseudo">:reset</span>”，选取所有重置按钮元素。 </span><br><span class="line"><span class="tag">i</span>) “<span class="pseudo">:button</span>”，选取所有按钮元素。 </span><br><span class="line"><span class="tag">j</span>) “<span class="pseudo">:file</span>”，选取所有文件上传域元素。 </span><br><span class="line"><span class="tag">k</span>) “<span class="pseudo">:hidden</span>”，选取所有不可见元素。</span><br></pre></td></tr></table></figure>
<p>7).表单对象属性过滤选择器<br>选取表单元素属性的过滤选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“<span class="pseudo">:enabled</span>”，选取所有可用元素。 </span><br><span class="line">“<span class="pseudo">:disabled</span>”，选取所有不可用元素。 </span><br><span class="line">“<span class="pseudo">:checked</span>”，选取所有被选中的元素，如单选框、复选框。 </span><br><span class="line">“<span class="pseudo">:selected</span>”，选取所有被选中项元素，如下拉列表框、列表框。</span><br></pre></td></tr></table></figure>
<p>四、JQuery中的DOM操作<br>一种与浏览器，平台，语言无关的接口。使用该接口可以轻松地访问页面中所有的标准组件。<br>DOM Core：DOM Core 并不专属于 JavaScript，任何一种支持 DOM 的程序设计语言都可以使用它。它的用途并非仅限于处理网页，也可以用来处理任何一种是用标记语言编写出来的文档，例如：XML。<br>HTML DOM：使用 JavaScript 和 DOM 为 HTML 文件编写脚本时，有许多专属于HTML-DOM的属性。<br>CSS-DOM：针对于CSS操作，在JavaScript中，CSS-DOM 主要用于获取和设置 style 对象的各种属性。 </p>
<p>1.查找节点<br>请见上面的“基本选择器”。 </p>
<p>2.创建节点<br>使用JQuery的工厂函数，创建一个新节点：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="variable">$newNode</span> = $(“&lt;p&gt;你好&lt;/p&gt;”);</span><br></pre></td></tr></table></figure></p>
<p>然后将新节点插入到指定元素节点处。 </p>
<p>3.插入节点<br>将新创建的节点，或获取的节点插入指定的位置。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“<span class="variable">$node</span>.append(<span class="variable">$newNode</span>)”，向每个匹配的元素内部的结尾处追加结尾处。如，“$(<span class="string">"p"</span>).append(<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>);”将<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>添加到<span class="string">"p"</span>内部的结尾处。 </span><br><span class="line">“<span class="variable">$newNode</span>.appendTo(<span class="variable">$node</span>)”，将新元素追加到每个匹配元素内部的结尾处。 </span><br><span class="line">“<span class="variable">$node</span>.prepend(<span class="variable">$newNode</span>)”，向每个匹配的元素内部的结尾处追加开始处。如，“$(<span class="string">"p"</span>).prepend(<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>);”将<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>添加到<span class="string">"p"</span>内部的起始处。 </span><br><span class="line">“<span class="variable">$newNode</span>.prependTo(<span class="variable">$node</span>)”， 将新元素追加到每个匹配元素内部的开始处。 </span><br><span class="line">“<span class="variable">$node</span>.after(<span class="variable">$newNode</span>)”，向每个匹配的元素的之后插入内容，是并列兄弟。如，“$(<span class="string">"p"</span>).after(<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>);”将<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>插入到<span class="string">"p"</span>的后边。它们是兄弟关系。 </span><br><span class="line">“<span class="variable">$newNode</span>.insertAfter(<span class="variable">$node</span>)”，将新元素插入到每个匹配元素之后。 </span><br><span class="line">“<span class="variable">$newNode</span>.before(<span class="variable">$node</span>)”，向每个匹配的元素的之前插入内容。如，“$(<span class="string">"p"</span>).before(<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>);”将<span class="string">"&lt;b&gt;Hello&lt;/b&gt;"</span>插入到<span class="string">"p"</span>的前面，它们是兄弟关系。 </span><br><span class="line">“<span class="variable">$node</span>.insertBefore(<span class="variable">$newNode</span>)”，将新元素插入到每个匹配元素之前。</span><br></pre></td></tr></table></figure>
<p>注意：如果插入的节点是不是新创建的，插入将变成移动操作。所以，在插入这样的节点之前应该使用clone的节点。 </p>
<p>4.删除节点<br>从DOM中删除所有匹配的元素。如，<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).<span class="keyword">remove</span>(<span class="string">".hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>删除所为class属性值为hello的p元素，还有它下面的所有元素。 </p>
<p>从DOM中清除所有匹配的元素。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).empty();</span><br></pre></td></tr></table></figure></p>
<p>清除所有p元素，还有它下面的所有元素。 </p>
<p>5.复制节点<br>克隆匹配的DOM元素。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).clone();</span><br></pre></td></tr></table></figure></p>
<p>返回克隆后的副本，但不具有任何行为。如果要将DOM的事件一起克隆，应该使用<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).clone(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>6.替换节点<br>将所有匹配的元素都替换为指定的 HTML 或 DOM 元素。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).replaceWith(<span class="string">"&lt;b&gt;Paragraph. &lt;/b&gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<p>将所有p元素，替换为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="tag">&lt;<span class="title">b</span>&gt;</span>Paragraph. <span class="tag">&lt;/<span class="title">b</span>&gt;</span>"</span><br></pre></td></tr></table></figure></p>
<p>与replaceWith相返：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"&lt;b&gt;Paragraph. &lt;/b&gt;"</span>).replaceAll(<span class="string">"p"</span>);</span><br></pre></td></tr></table></figure></p>
<p>7.包裹节点<br>wrap()：将指定节点用其他标记包裹起来。该方法对于需要在文档中插入额外的结构化标记非常有用， 而且不会破坏原始文档的语义。如，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$("p").wrap("<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'wrap'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>");</span><br></pre></td></tr></table></figure></p>
<p>每个p元素被包裹到<div>中。<br>wrapAll()：将所有匹配的元素用一个元素来包裹。而wrap()方法是将所有的元素进行单独包裹。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).wrapAll(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>);</span><br></pre></td></tr></table></figure></div></p>
<p>将所有p元素包裹到<div>中。<br>wrapInner()：将每一个匹配的元素的子内容(包括文本节点)用其他结构化标记包裹起来。如，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$("p").wrapInner("<span class="tag">&lt;<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">b</span>&gt;</span>");</span><br><span class="line"> <span class="tag">&lt;<span class="title">b</span>&gt;</span>被每一个p元素包裹。</span><br></pre></td></tr></table></figure></div></p>
<p>8.属性设置<br>attr()：获取属性和设置属性。<br>当为该方法传递一个参数时，即为某元素的获取指定属性。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"img"</span>).attr(<span class="string">"src"</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取img元素的src属性值。<br>当为该方法传递两个参数时，即为某元素设置指定属性的值。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"img"</span>).attr(<span class="string">"src"</span>,<span class="string">"test.jpg"</span>);</span><br></pre></td></tr></table></figure></p>
<p>设置img元素的src属性值为test.jsp。<br>jQuery 中有很多方法都是一个函数实现获取和设置。如：<br>attr()，html()，text()，val()，height()，width()，css()等。<br>removeAttr()：删除指定元素的指定属性。 </p>
<p>9.样式操作<br>可以通过“attr()”设置或获取css样式。<br>追加样式：addClass() 。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).addClass(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure></p>
<p>向所有P元素中追加“selected”样式。<br>移除样式：removeClass() — 从匹配的元素中删除全部或指定的class。如，<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).removeClass(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure></p>
<p>删除所有P元素中的“selected”。<br>切换样式：toggleClass() — 控制样式上的重复切换。如果类名存在则删除它，如果类名不存在则添加它。如，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).<span class="function"><span class="title">toggleClass</span><span class="params">(<span class="string">"selected"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>所有的P元素中，如果存在“selected”样式就删除“selected”样式，否则就添加“selected”样式。<br>判断是否含有某个样式：hasClass() — 判断元素中是否含有某个 class，有返回 true； 否则返回 false。如，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(this).<span class="function"><span class="title">hasClass</span><span class="params">(<span class="string">"protected"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>判断当前节点是否有“protected”样式。 </p>
<p>10.设置或获取HTML、文本和值<br>读取和设置某个元素中的 HTML 内容： html()，该方法可以用于 XHTML，但不能用于 XML 文档。<br>读取和设置某个元素中的文本内容：text()，该方法既可以用于 XHTML 也可以用于 XML 文档。<br>读取和设置某个元素中的值：val()，该方法类似 JavaScript 中的 value 属性。对于文本框，下拉列表框，单选框该方法可返回元素的值(多选框只能返回第一个值)。如果为多选下拉列表框，则返回一个包含所有选择值的数组。 </p>
<p>11.常用遍历节点的方法<br>取得匹配元素的所有子元素组成的集合：children()。该方法只考虑第一层子元素而不考虑任何后代元素。<br>取得匹配元素后面紧邻的兄弟元素的集合(但集合中只有一个元素)：next()。<br>取得匹配元素前面紧邻的兄弟元素的集合(但集合中只有一个元素)：prev()。<br>取得匹配元素前后所有的兄弟元素: siblings()。 </p>
<p>12.CSS-DOM操作<br>获取和设置元素的样式属性：css()。<br>获取和设置元素透明度：opacity()属性。<br>获取和设置元素高度，宽度：height()，width()。在设置值时，若只传递数字，则默认单位是px。如需要使用其他单位则需传递一个字符串，例如 “$(“p:first”).height(“2em”)”；<br>获取元素在当前视窗中的相对位移：offset()。它返回的对象包含了两个属性：top，left。该方法只对可见元素有效。 </p>
<p>五、JQuery中的事件 </p>
<p>1.加载DOM<br>在页面加载完毕后，浏览器会通过 JavaScript 为 DOM 元素添加事件。在常规的 JavaScript 代码中，通常使用 window.onload 方法，在JQuery 中使用$(document).ready() 方法。JQuery中的简化写法“$()”。在window.onload中注册事件时，只能在一个window.onload体中注册。但使用JQuery，可以在多个$(document).ready()或$()中注册。 </p>
<p>2.事件绑定<br>对匹配的元素对指定的事件绑定。如，昨天我们在window.onload中绑定事件的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).onclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( $(<span class="keyword">this</span>).text() ); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在JQuery的$(document).ready()中可以这样绑定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( $(<span class="keyword">this</span>).text() ); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用bind()，可以这样绑定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( $(<span class="keyword">this</span>).text() ); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.合成事件<br>hover()：模拟光标悬停时间。当光标移动到元素上时，会触发指定的第一个函数，当光标移出这个元素时，会触发指定的第二个函数。如，悬停效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"td"</span>).hover( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;$(<span class="keyword">this</span>).addClass(<span class="string">"hover"</span>);&#125;,           </span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;$(<span class="keyword">this</span>).removeClass(<span class="string">"hover"</span>);&#125;);</span><br></pre></td></tr></table></figure></p>
<p>toggle()：用于模拟鼠标连续单击事件。第一次单击元素，触发指定的第一个函数，当再一次单击同一个元素时，则触发指定的第二个函数，如果有更多个函数，则依次触发，直到最后一个。如，设置元素的选择与非选中效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"td"</span>).toggle( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;$(<span class="keyword">this</span>).addClass(<span class="string">"selected"</span>);&#125;,        </span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;$(<span class="keyword">this</span>).removeClass(<span class="string">"selected"</span>);&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用toggle()而不传递参数，效果为切换元素的可见状态。 </p>
<p>4.事件的冒泡<br>事件会按照 DOM 层次结构像水泡一样不断向上只止顶端。<br>解决：在事件处理函数中返回 false，会对事件停止冒泡。还可以停止元素的默认行为。<br>目前的所有UI交互或其事件，都支持这个特性。在自己的事件处理函数返回false将中止事件的继续向下传递。返回true事件继续向下传递。 </p>
<p>5.事件对象的属性<br>事件对象：当触发事件时，事件对象就被创建了。在程序中使用事件只需要为处理函数添加一个参数。在事件处理函数中使用些参数。如，获取事件发生时，相对于页面的位置：event.pageX, event.pageY，event是事件处理函数的参数。 </p>
<p>6.移除事件<br>移除某按钮上的所有click 事件：$(“btn”).unbind(“click”)<br>移除某按钮上的所有事件：$(“btn”).unbind();<br>one()：该方法可以为元素绑定处理函数。当处理函数触发一次后，事件立即被删除。即在每个对象上，事件处理函数只会被执行一次。 </p>
<p>六、JQuery中的DOM动画<br>通过设置DOM对象的显示与隐藏方式，可以产生动画效果。 </p>
<p>1.无动画效果的隐藏与显示<br>hide()：在HTML文档中，为一个元素调用hide()方法会将该元素的display样式改为none。代码功能同css(“display”, “none”);相同。<br>show()：将元素的display样式改为先前的显示状态。<br>toggle()：切换元素的可见状态：如果元素时可见的，则切换为隐藏；如果元素时隐藏的，则切换为可见的。 </p>
<p>2.通过设置透明度效果的隐藏与显示，达到淡入淡出的动画效果<br>fadeIn()，fadeOut()：只改变元素的透明度。fadeOut() 会在指定的一段时间内降低元素的不透明度，直到元素完全消失。fadeIn() 则相反。如，用600毫秒缓慢的将段落淡入：$(“p”).fadeIn(“slow”);。<br>fadeTo()：把不透明度以渐近的方式调整到指定的值(0 – 1 之间)。并在动画完成后可选地触发一个回调函数。如，用200毫秒快速将段落的透明度调整到0.25，动画结束后，显示一个“Animation Done”信息框：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).fadeTo(<span class="string">"fast"</span>, <span class="number">0.25</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"Animation Done."</span>); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.通过设置高度效果的隐藏与显示，达到滑下与收起的动画效果<br>slideDown()，slideUp()：只会改变元素的高度。如果一个元素的display属性为none，当调用slideDown() 方法时，这个元素将由上至下延伸显示。slideUp() 方法正好相反，元素由下至上缩短隐藏。如，用600毫秒缓慢的将段落滑下：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"p"</span>).slideDown(<span class="string">"slow"</span>);。</span><br></pre></td></tr></table></figure></p>
<p>slideToggle()：通过高度变化来切换匹配元素的可见性。如，200毫秒快速将段落滑上或滑下，动画结束后，会显示一个“Animation Done”信息框：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).slideToggle(<span class="string">"fast"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"Animation Done."</span>); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用JavaScript、JQuery可以处理当前页面的动态更新，再结合CSS样式可以做出十分漂亮的UI，甚至比桌面软件UI漂亮的多。JavaScript的编写与调试非常麻烦，所以也有一些公司出品了专门针对JavaScript应用的简化开发，比如Google出品的GWT，可以像使用Java编写swing那样编写JavaScript。它为用户提供像swing那样的UI接口与事件等操作并且支持JAVA的核心库。使用GWT自己的编译器，可以将JAVA代码编译为JavaScript代码、CSS样式文件和HTML。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Front-End/">Front End</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/前端/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-some-css-selector" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/some-css-selector/" class="article-date">
  	<time datetime="2015-12-05T14:23:35.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/some-css-selector/">一些CSS选择器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一些CSS选择器">一些CSS选择器</h1><h2 id="1-*">1.*</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="rules">&#123;</span><br><span class="line"><span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>　　在我们看比较高级的选择器之前，应该认识下这个众所周知的清空选择器。星号呢会将页面上所有每一个元素都选到。许多开发者都用它来清空margin和padding。当然你在练习的时候使用这个没问题，但是我不建议在生产环境中使用它。它会给浏览器凭添许多不必要的东西。</p>
<p>*也可以用来选择某元素的所有子元素。</p>
<p> #id</p>
<pre><code><span class="id">#container</span> * <span class="rules">{
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
</code></pre><p>　　它会选中#container下的所有元素。当然，我还是不建议你去使用它，如果可能的话。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/star.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="2-_#X">2. #X</h2><pre><code><span class="id">#container</span> <span class="rules">{
   <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">960px</span></span></span>;
   <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>  
</code></pre><p>　　在选择器中使用#可以用id来定位某个元素。大家通常都会这么使用，然后使用的时候大家还是得相当小心的。<br>需要问自己一下：我是不是必须要给这个元素来赋值个id来定位它呢？</p>
<p>　　id选择器是很严格的并且你没办法去复用它。如果可能的话，首先试试用标签名字，HTML5中的新元素，或者是伪类。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/id.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="3-_-X">3. .X</h2><pre><code><span class="class">.error</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　这是个class选择器。它跟id选择器不同的是，它可以定位多个元素。当你想对多个元素进行样式修饰的时候就可以使用class。当你要对某个特定的元素进行修饰那就是用id来定位它。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/class.html" target="_blank" rel="external">DEMO</a></p>
<p>　</p>
<h2 id="4-_X_Y">4. X Y</h2><pre><code><span class="tag">li</span> <span class="tag">a</span> <span class="rules">{
  <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
}</span>  
</code></pre><p>　　下一个常用的就是descendant选择器。如果你想更加具体的去定位元素，你可以使用它。例如，假如，你不需要定位所有的a元素，而只需要定位li标签下的a标签？这时候你就需要使用descendant选择器了。</p>
<p>　　专家提示：如果你的选择器像X Y Z A B.error这样，那你就错了。时刻都提醒自己，是否真的需要对那么多元素修饰。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/descend.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="5-_X">5. X</h2><pre><code><span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>; }</span>
<span class="tag">ul</span> <span class="rules">{ <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0</span></span></span>; }</span>
</code></pre><p>　　如果你想定位页面上所有的某标签，不是通过id或者是’class’，这简单，直接使用类型选择器。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/tagName.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="6-_X:visited_and_X:link">6. X:visited and X:link</h2><pre><code><span class="tag">a</span><span class="pseudo">:link</span> <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value">red</span></span>;}</span>
<span class="tag">a</span><span class="pseudo">:visited</span> <span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"> purple</span></span>;}</span>  
</code></pre><p>　　我们使用:link这个伪类来定位所有还没有被访问过的链接。</p>
<p>　　另外，我们也使用:visited来定位所有已经被访问过的链接。  </p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/links.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="7-_X+Y">7. X+Y</h2><pre><code><span class="tag">ul</span> + <span class="tag">p</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>  
</code></pre><p>　　这个叫相邻选择器。它指挥选中指定元素的直接后继元素。上面那个例子就是选中了所有ul标签后面的第一段，并将它们的颜色都设置为红色。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/adjacent.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="8-_X&gt;Y">8. X&gt;Y</h2><pre><code><span class="tag">div</span><span class="id">#container</span> &gt; <span class="tag">ul</span> <span class="rules">{
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>  
</code></pre><p>　　X Y和X &gt; Y的差别就是后面这个指挥选择它的直接子元素。看下面的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item</span><br><span class="line">	<span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">	   <span class="tag">&lt;<span class="title">li</span>&gt;</span> Child <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　#container &gt; ul只会选中id为’container’的div下的所有直接ul元素。它不会定位到如第一个li下的ul元素。</p>
<p>　　由于某些原因，使用子节点组合选择器会在性能上有许多的优势。事实上，当在javascript中使用css选择器时候是强烈建议这么做的。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/childcombinator.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="9-_X_~_Y">9. X ~ Y</h2><pre><code><span class="tag">ul</span> ~ <span class="tag">p</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>  
</code></pre><p>　　兄弟节点组合选择器跟X+Y很相似，然后它又不是那么的严格。ul + p选择器只会选择紧挨跟着指定元素的那些元素。而这个选择器，会选择跟在目标元素后面的所有匹配的元素。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/generalcombinator.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="10-_X[title]">10. X[title]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[title]</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>;
}</span>
</code></pre><p>　　这个叫属性选择器，上面的这个例子中，只会选择有title属性的元素。那些没有此属性的锚点标签将不会被这个代码修饰。那再想想如果你想更加具体的去筛选？那…  </p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="11-_X[href=”foo”]">11. X[href=”foo”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[href="http://strongme.cn"]</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#1f6053</span></span></span>; <span class="comment">/* nettuts green */</span>
}</span>
</code></pre><p>　　上面这片代码将会把href属性值为<a href="http://strongme.cn的锚点标签设置为绿色，而其他标签则不受影响。" target="_blank" rel="external">http://strongme.cn的锚点标签设置为绿色，而其他标签则不受影响。</a></p>
<p>注意我们将值用双引号括起来了。那么在使用Javascript的时候也要使用双引号括起来。可以的话，尽量使用标准的CSS3选择器。</p>
<p>　　这样可以用了，但是还是有点死，如果不是这个链接，而是类似的链接，那么这时就得用正则表达式了。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes2.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="12-_X[href*=”strongme”]">12. X[href*=”strongme”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[href*="strongme"]</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#1f6053</span></span></span>;
}</span>
</code></pre><p>　　Tada,正是我们需要的，这样，就指定了strongme这个值必须出现在锚点标签的href属性中，不管是strongme.cn还是strongme.com还是www.strongme.cn都可以被选中。<br>但是记得这是个很宽泛的表达方式。如果锚点标签指向的不是strongme相关的站点，如果要更加具体的限制的话，那就使用^和$，分别表示字符串的开始和结束。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes3.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="13-_X[href^=”href”]">13. X[href^=”href”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[href^="http"]</span> <span class="rules">{
   <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(path/to/external/icon.png) no-repeat</span></span>;
   <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">10px</span></span></span>;
}</span>
</code></pre><p>　　大家肯定好奇过，有些站点的锚点标签旁边会有一个外链图标，我也相信大家肯定见过这种情况。这样的设计会很明确的告诉你会跳转到别的网站。<br>用克拉符号就可以轻易做到。它通常使用在正则表达式中标识开头。如果我们想定位锚点属性href中以http开头的标签，那我们就可以用与上面相似的代码。</p>
<p>注意我们没有搜索<a href="http://，那是没必要的，因为它都不包含https://。" target="_blank" rel="external">http://，那是没必要的，因为它都不包含https://。</a></p>
<p>　　那如果我们想找到所有指向一张图片的锚点标签呢？那我们来使用下&amp;字符。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes4.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="14-_X[href$=”-jpg”]">14. X[href$=”.jpg”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[href$=".jpg"]</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　这次我们又使用了正则表达式$，表示字符串的结尾处。这段代码的意思就是去搜索所有的图片链接，或者其它链接是以.jpg结尾的。但是记住这种写法是不会对gifs和pngs起作用的。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes5.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="15-_X[data-*=”foo”]">15. X[data-*=”foo”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[data-filetype="image"]</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　在回到第8条，我们如何把所有的图片类型都选中呢png,jpeg,’jpg’,’gif’？我们可以使用多选择器。看下面：</p>
<pre><code>a[href<span class="variable">$=</span><span class="string">".jpg"</span>],
a[href<span class="variable">$=</span><span class="string">".jpeg"</span>],
a[href<span class="variable">$=</span><span class="string">".png"</span>],
a[href<span class="variable">$=</span><span class="string">".gif"</span>] {
   <span class="keyword">color</span>: red;
}
</code></pre><p>　　但是这样写着很蛋疼啊，而且效率会很低。另外一个办法就是使用自定义属性。我们可以给每个锚点加个属性data-filetype指定这个链接指向的图片类型。</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"path/to/image.jpg"</span> <span class="attribute">data-filetype</span>=<span class="value">"image"</span>&gt;</span> Image Link <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><p>　　那有了这个钩子，我们就可以去用标准的办法只去选定文件类型为image的锚点了。</p>
<pre><code><span class="tag">a</span><span class="attr_selector">[data-filetype="image"]</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes6.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="16-_X[foo~=”bar”]">16. X[foo~=”bar”]</h2><pre><code><span class="tag">a</span><span class="attr_selector">[data-info~="external"]</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>

<span class="tag">a</span><span class="attr_selector">[data-info~="image"]</span> <span class="rules">{
   <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>  
</code></pre><p>　　这个我想会让你的小伙伴惊呼妙极了。很少有人知道这个技巧。这个~符号可以定位那些某属性值是空格分隔多值的标签。<br>继续使用第15条那个例子，我们可以设置一个data-info属性，它可以用来设置任何我们需要的空格分隔的值。这个例子我们将指示它们为外部连接和图片链接。</p>
<pre><code>&lt;a href=<span class="string">"path/to/image.jpg"</span> <span class="preprocessor">data</span>-<span class="preprocessor">info</span>=<span class="string">"external image"</span>&gt; Click Me, Fool &lt;/a&gt;
</code></pre><p>　　给这些元素设置了这个标志之后，我们就可以使用~来定位这些标签了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Target data-info attr that contains the value "external" */</span></span><br><span class="line"><span class="tag">a</span><span class="attr_selector">[data-info~="external"]</span> <span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* And which contain the value "image" */</span></span><br><span class="line"><span class="tag">a</span><span class="attr_selector">[data-info~="image"]</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="17-_X:checked">17. X:checked</h2><pre><code><span class="tag">input</span><span class="attr_selector">[type=radio]</span><span class="pseudo">:checked</span> <span class="rules">{
   <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
</code></pre><p>　　上面这个伪类写法可以定位那些被选中的单选框和多选框，就是这么简单。  </p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/checked.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="18-_X:after">18. X:after</h2><p>　　before和after这俩伪类。好像每天大家都能找到使用它们的创造性方法。它们会在被选中的标签周围生成一些内容。<br>当使用.clear-fix技巧时许多属性都是第一次被使用到里面的。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.clearfix</span><span class="pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.clearfix</span> &#123; </span><br><span class="line">   *<span class="attribute">display</span>: inline-block; </span><br><span class="line">   <span class="attribute">_height</span>: <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　上面这段代码会在目标标签后面补上一段空白，然后将它清除。这个方法你一定得放你的聚宝盆里面。特别是当overflow:hidden方法不顶用的时候，这招就特别管用了。<br>还想看其他创造性的使用这个伪类，看这里。</p>
<p>根据CSS3标准规定，可以使用两个冒号<code>::</code>。然后为了兼容性，浏览器也会接受一个双引号的写法。其实在这个情况下，用一个冒号还是比较明智的。</p>
<h2 id="19-_X::hover">19. X::hover</h2><pre><code><span class="tag">div</span><span class="pseudo">:hover</span> <span class="rules">{
  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#e3e3e3</span></span></span>;
}</span>
</code></pre><p>　　不用说，大家肯定知道它。官方的说法是user action pseudo class.听起来有点儿迷糊，其实还好。如果想在用户鼠标飘过的地方涂点儿彩，那这个伪类写法可以办到。</p>
<p>注意旧版本的IE只会对加在锚点<code>a</code>标签上的<code>:hover</code>伪类起作用。</p>
<p>　　通常大家在鼠标飘过锚点链接时候加下边框的时候用到它。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="pseudo">:hover</span> &#123;</span><br><span class="line"> <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专家提示：</span></span><br><span class="line"><span class="attribute">border-bottom</span>:<span class="number">1px</span> solid black;比<span class="attribute">text-decoration</span>:underline;  <span class="comment">//要好看很多。</span></span><br></pre></td></tr></table></figure>
<h2 id="20-_X:not(selector)">20. X:not(selector)</h2><pre><code><span class="tag">div</span><span class="pseudo">:not(</span><span class="id">#container</span>) <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> blue</span></span>;
}</span>  
</code></pre><p>　　取反伪类是相当有用的，假设我们要把除id为container之外的所有div标签都选中。那上面那么代码就可以做到。</p>
<p>　　或者说我想选中所有出段落标签之外的所有标签。</p>
<pre><code>*<span class="pseudo">:not(p)</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>;
}</span>  
</code></pre><p>　　<br><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/not.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="21-_X::pseudoElement">21. X::pseudoElement</h2><pre><code><span class="tag">p</span><span class="pseudo">::first-line</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">1.2em</span></span></span>;
}</span>
</code></pre><p>　　</p>
<p>我们可以使用::来选中某标签的部分内容，如地一段，或者是第一个字没有。但是记得必须使用在块式标签上才起作用。</p>
<p>伪标签是由两个冒号<code>::</code>组成的。</p>
<p>　　定位第一个字</p>
<pre><code><span class="tag">p</span><span class="pseudo">::first-letter</span> <span class="rules">{
   <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
   <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2em</span></span></span>;
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
   <span class="rule"><span class="attribute">font-family</span>:<span class="value"> cursive</span></span>;
   <span class="rule"><span class="attribute">padding-right</span>:<span class="value"> <span class="number">2px</span></span></span>;
}</span>
</code></pre><p>　　上面这段代码会找到页面上所有段落，并且指定为每一段的第一个字。</p>
<p>　　它通常在一些新闻报刊内容的重点突出会使用到。</p>
<p>　　定位某段的第一行</p>
<pre><code><span class="tag">p</span><span class="pseudo">::first-line</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
   <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.2em</span></span></span>;
}</span>
</code></pre><p>　　跟::first-line相似，会选中段落的第一行 。</p>
<p>　　为了兼容性，之前旧版浏览器也会兼容单冒号的写法，例如:first-line,:first-letter,:before,:after.但是这个兼容对新介绍的特性不起作用。  </p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/pseudoElements.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="22-_X:nth-child(n)">22. X:nth-child(n)</h2><pre><code><span class="tag">li</span><span class="pseudo">:nth-child(3)</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　还记得我们面对如何取到推跌式标签的第几个元素是无处下手的时光么，有了nth-child那日子就一去不复返了。</p>
<p>　　请注意nth-child接受一个整形参数，然后它不是从0开始的。如果你想获取第二个元素那么你传的值就是li:nth-child(2).</p>
<p>　　我们甚至可以获取到由变量名定义的个数个子标签。例如我们可以用li:nth-child(4n)去每隔3个元素获取一次标签。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nth.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="23-_X:nth-last-child(n)">23. X:nth-last-child(n)</h2><pre><code><span class="tag">li</span><span class="pseudo">:nth-last-child(2)</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　假设你在一个ul标签中有N多的元素，而你只想获取最后三个元素，甚至是这样li:nth-child(397)，你可以用nth-last-child伪类去代替它。</p>
<p>　　这个技巧可以很正确的代替第16个TIP，不同的就是它是从结尾处开始的，倒回去的。  </p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthLast.html" target="_blank" rel="external">DEMO</a>
　　</p>
<h2 id="24-_X:nth-of-type(n)">24. X:nth-of-type(n)</h2><pre><code><span class="tag">ul</span><span class="pseudo">:nth-of-type(3)</span> <span class="rules">{
   <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
</code></pre><p>　　曾几何时，我们不想去选择子节点，而是想根据元素的类型来进行选择。</p>
<p>　　想象一下有5个ul标签。如果你只想对其中的第三个进行修饰，而且你也不想使用id属性，那你就可以使用nth-of-type(n)伪类来实现了，上面的那个代码，只有第三个ul标签会被设置边框。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthOfType.html" target="_blank" rel="external">DEMO</a></p>
<p>　</p>
<h2 id="25-_X:nth-last-of-type(n)">25. X:nth-last-of-type(n)</h2><pre><code><span class="tag">ul</span><span class="pseudo">:nth-last-of-type(3)</span> <span class="rules">{
   <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
</code></pre><p>　　同样，也可以类似的使用nth-last-of-type来倒序的获取标签。</p>
<p>　</p>
<h2 id="26-_X:first-child">26. X:first-child</h2><pre><code><span class="tag">ul</span> <span class="tag">li</span><span class="pseudo">:first-child</span> <span class="rules">{
   <span class="rule"><span class="attribute">border-top</span>:<span class="value"> none</span></span>;
}</span>
</code></pre><p>　　这个结构性的伪类可以选择到第一个子标签，你会经常使用它来取出第一个和最后一个的边框。</p>
<p>　　假设有个列表，没个标签都有上下边框，那么效果就是第一个和最后一个就会看起来有点奇怪。这时候就可以使用这个伪类来处理这种情况了。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" target="_blank" rel="external">DEMO</a></p>
<p>　　</p>
<h2 id="27-_X:last-child">27. X:last-child</h2><pre><code><span class="tag">ul</span> &gt; <span class="tag">li</span><span class="pseudo">:last-child</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>;
}</span>
</code></pre><p>　　跟first-child相反，last-child取的是父标签的最后一个标签。</p>
<p>　　例如标签</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;ul&gt;</span></span><br><span class="line">   <span class="variable">&lt;li&gt;</span> List Item <span class="variable">&lt;/li&gt;</span></span><br><span class="line">   <span class="variable">&lt;li&gt;</span> List Item <span class="variable">&lt;/li&gt;</span></span><br><span class="line">   <span class="variable">&lt;li&gt;</span> List Item <span class="variable">&lt;/li&gt;</span></span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line"> width: <span class="number">200</span>px;</span><br><span class="line"> background: <span class="comment">#292929;</span></span><br><span class="line"> color: white;</span><br><span class="line"> list-style: <span class="keyword">none</span>;</span><br><span class="line"> padding-left: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li &#123;</span><br><span class="line"> padding: <span class="number">10</span>px;</span><br><span class="line"> border-bottom: <span class="number">1</span>px solid black;</span><br><span class="line"> border-top: <span class="number">1</span>px solid <span class="comment">#3c3c3c;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　上面的代码将设置背景色，移除浏览器默认的内边距，为每个li设置边框以凸显一定的深度。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="28-_X:only-child">28. X:only-child</h2><pre><code><span class="tag">div</span> <span class="tag">p</span><span class="pseudo">:only-child</span> <span class="rules">{
   <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;
}</span>
</code></pre><p>　　说实话，你会发现你几乎都不会用到这个伪类。然而，它是可用的，有会需要它的。</p>
<p>　　它允许你获取到那些只有一个子标签的父标签。就像上面那段代码，只有一个段落标签的div才被着色。</p>
<pre><code><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span> My paragraph here. <span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>

<span class="tag">&lt;<span class="title">div</span>&gt;</span>
   <span class="tag">&lt;<span class="title">p</span>&gt;</span> Two paragraphs total. <span class="tag">&lt;/<span class="title">p</span>&gt;</span>
   <span class="tag">&lt;<span class="title">p</span>&gt;</span> Two paragraphs total. <span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>  
</code></pre><p>　　上面例子中，第二个div不会被选中。一旦第一个div有了多个子段落，那这个就不再起作用了。</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyChild.html" target="_blank" rel="external">DEMO</a></p>
<p>　</p>
<h2 id="29-_X:only-of-type">29. X:only-of-type</h2><pre><code><span class="tag">li</span><span class="pseudo">:only-of-type</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
}</span>  
</code></pre><p>　　结构性伪类可以用的很聪明。它会定位某标签只有一个子标签的目标。设想你想获取到只有一个子标签的ul标签？</p>
<p>　　使用ul li会选中所有li标签。这时候就要使用only-of-type了。</p>
<pre><code><span class="tag">ul</span> &gt; <span class="tag">li</span><span class="pseudo">:only-of-type</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
}</span>
</code></pre><p>　</p>
<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyOfType.html" target="_blank" rel="external">DEMO</a></p>
<h2 id="30-_X:first-of-type">30. X:first-of-type</h2><p>　　first-of-type伪类可以选择指定标签的第一个兄弟标签。</p>
<p>　　测试</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">p</span>&gt;</span> My paragraph here. <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item 1 <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item 2 <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item 3 <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span> List Item 4 <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　来你把List Item 2取出来，如果你已经取出来或者是放弃了，来继续。</p>
<p>　　解决办法1</p>
<p>　　办法很多，我们看一些比较方便的。首先是first-of-type。</p>
<pre><code><span class="tag">ul</span><span class="pseudo">:first-of-type</span> &gt; <span class="tag">li</span><span class="pseudo">:nth-child(2)</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
}</span>
</code></pre><p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstOfType.html" target="_blank" rel="external">DEMO</a></p>
<p>　　找到第一个ul标签，然后找到直接子标签li，然后找到第二个子节点。</p>
<p>　　解决办法2</p>
<p>　　另一个解决办法就是邻近选择器。</p>
<pre><code><span class="tag">p</span> + <span class="tag">ul</span> <span class="tag">li</span><span class="pseudo">:last-child</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
}</span>  
</code></pre><p>　　这种情况下，找到p下的直接ul标签，然后找到它的最后一个直接子标签。</p>
<p>　　解决办法3</p>
<p>　　我们可以随便玩耍这些选择器。来看看：</p>
<pre><code><span class="tag">ul</span><span class="pseudo">:first-of-type</span> <span class="tag">li</span><span class="pseudo">:nth-last-child(1)</span> <span class="rules">{
   <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;   
}</span>  
</code></pre><p>　　先获取到页面上第一个ul标签，然后找到最后一个子标签。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Front-End/">Front End</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/前端/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C++虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/C++虚函数/" class="article-date">
  	<time datetime="2015-12-05T08:39:55.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/C++虚函数/">C++虚函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C++的精髓——虚函数">C++的精髓——虚函数</h1><p>　　简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略.多态有个关键之处就是一切用指向基类的指针或引用来操作对象,指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。 </p>
<p>定义虚函数的限制：  </p>
<p>（1）非类的成员函数不能定义为虚函数，类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。实际上，优秀的程序员常常把基类的析构函数定义为虚函数。因为，将基类的析构函数定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析构函数。  </p>
<p>（2）只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。  </p>
<p>（3）当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数（函数名相同、参数列表完全一致、返回值类型相关）自动成为虚函数。  </p>
<p>（4）如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种同名函数。</p>
<p>纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数！ </p>
<p>define : virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;  </p>
<p>　　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。<br>一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.</p>
<h2 id="虚函数">虚函数</h2><p>引入原因：为了方便使用多态特性，我们常常需要在基类中定义虚函数。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cman</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span>(<span class="params"></span>)</span>&#123;……&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CChild</span> : <span class="title">public</span> <span class="title">CMan</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span>(<span class="params"></span>)</span>&#123;……&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMan m_man;</span><br><span class="line"></span><br><span class="line">CChild m_child;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这才是使用的精髓，如果不定义基类的指针去使用，没有太大的意义</span></span><br><span class="line"></span><br><span class="line">CMan *p ;</span><br><span class="line"></span><br><span class="line">p = &amp;m_man ;</span><br><span class="line"></span><br><span class="line">p-&gt;Eat(); <span class="comment">//始终调用CMan的Eat成员函数，不会调用 CChild 的</span></span><br><span class="line"></span><br><span class="line">p = &amp;m_child;</span><br><span class="line"></span><br><span class="line">p-&gt;Eat(); <span class="comment">//如果子类实现(覆盖)了该方法，则始终调用CChild的Eat函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不会调用CMan 的 Eat 方法；如果子类没有实现该函数，则调用CMan的Eat函数</span></span><br><span class="line"></span><br><span class="line">p-&gt;Move(); <span class="comment">//子类中没有该成员函数，所以调用的是基类中的</span></span><br></pre></td></tr></table></figure></p>
<h2 id="纯虚函数">纯虚函数</h2><p>引入原因：</p>
<p>1、同“虚函数”；</p>
<p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>纯虚函数就是基类只定义了函数体，没有实现过程定义方法如下</p>
<pre><code><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//直接=0 不要 在cpp中定义就可以了</span>
</code></pre><p>　　纯虚函数相当于接口，不能直接实例话，需要派生类来实现函数定义。有的人可能在想，定义这些有什么用啊 ，我觉得很有用。</p>
<p>　　比如你想描述一些事物的属性给别人，而自己不想去实现，就可以定义为纯虚函数。说的再透彻一些。比如盖楼房，你是老板，你给建筑公司描述清楚你的楼房的特性，多少层，楼顶要有个花园什么的建筑公司就可以按照你的方法去实现了，如果你不说清楚这些，可能建筑公司不太了解你需要楼房的特性。用纯需函数就可以很好的分工合作了。</p>
<p>虚函数和纯虚函数区别</p>
<p>观点一：</p>
<p>类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，这样的话，这样编译器就可以使用后期绑定来达到多态了</p>
<p>纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;<span class="comment">//普通类函数</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>;<span class="comment">//虚函数</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>观点二：</p>
<p>虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现</p>
<p>观点三：</p>
<p>虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然我们也可以完成自己的实现。纯虚函数的类用于“介面继承”，主要用于通信协议方面。关注的是接口的统一性，实现由子类完成。一般来说，介面类中只有纯虚函数的。</p>
<p>观点四：</p>
<p>错误：带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。</p>
<p>虚函数是为了继承接口和默认行为</p>
<p>纯虚函数只是继承接口，行为必须重新定义</p>
<p>虚基类的初始化<br>—　</p>
<p>虚基类的初始化与一般多继承的初始化在语法上是一样的,但构造函数的调用次序不同.派生类构造函数的调用次序有三个原则:</p>
<p>(1)虚基类的构造函数在非虚基类之前调用;</p>
<p>(2)若同一层次中包含多个虚基类,这些虚基类的构造函  虚基类和非虚基类的区别虚基类和非虚基类的区别数按它们说明的次序调用;</p>
<p>(3)若虚基类由非虚基类派生而来,则仍先调用基类构造函数,再调用派生类的构造函数.</p>
<p>C++的虚基类　　在派生类继承基类时，加上一个virtual关键词则为虚拟基类继承，如：</p>
<pre><code><span class="keyword">class</span> derive:<span class="keyword">virtual</span> <span class="keyword">public</span> base{};
</code></pre><p>　　虚基类主要解决在多重继承时，基类可能被多次继承，虚基类主要提供一个基类给派生类，如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:<span class="typename">public B&#123;&#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:<span class="typename">public B&#123;&#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:<span class="typename">public D1</span>,<span class="typename">public D2&#123;&#125;;</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　这里C在D1,D2上继承，但有两个基类，造成混乱。因而使用虚基类，即：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:<span class="typename">virtual public B&#123;&#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:<span class="typename">virtual publicB&#123;&#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:<span class="typename">public D1</span>,<span class="typename">public D2</span></span></span><br></pre></td></tr></table></figure>
<h2 id="在使用虚基类时要注意：">在使用虚基类时要注意：</h2><p>(1) 一个类可以在一个类族中既被用作虚基类，也被用作非虚基类。
　　</p>
<p>(2) 在派生类的对象中，同名的虚基类只产生一个虚基类子对象，而某个非虚基类产生各自的子对象。
　　</p>
<p>(3) 虚基类子对象是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。  </p>
<p>(4) 最远派生类是指在继承结构中建立对象时所指定的类。
　　</p>
<p>(5) 派生类的构造函数的成员初始化列表中必须列出对虚基类构造函数的调用；如果未列出，则表示使用该虚基类的缺省构造函数。
　　</p>
<p>(6) 从虚基类直接或间接派生的派生类中的构造函数的成员初始化列表中都要列出对虚基类构造函数的调用。但仅仅用建立对象的最远派生类的构造函数调用虚基类的构造函数，而该派生类的所有基类中列出的对虚基类的构造函数的调用在执行中被忽略，从而保证对虚基类子对象只初始化一次。
　　</p>
<p>(7) 在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。</p>
<p>静态联编：在程序链接阶段就可以确定的调用。</p>
<p>动态联编：在程序执行时才能确定的调用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-小记-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/17/小记-2/" class="article-date">
  	<time datetime="2015-11-16T16:36:28.000Z" itemprop="datePublished">2015-11-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/17/小记-2/">小记(2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　去年的今天下着雨，和现在一样的小雨。<br>　　身体会很诚实，每年这个时段都是同样的状态，习惯性将自己隐藏在纸盒中，营造一种沉闷的氛围。唱着听着快10年的《拥抱》，放任自己迷醉在修罗场边的荷花池。<br>　　晚上借了同学的车子，去了第一次来这个城市​进的理发店，很小，当初去是因为他在放着我正哼唱的小调，今天来是想要再回味我在这个城市的几年痕迹。似乎没有什么不同，同学的车子很棒，让我感觉比去年的现在好一些。<br>　　快一年没来了，老板还认得我，问我最近怎样、今后的打算。老板变化不大，和原来一样的健谈，与顾客熟稔，看起来非常安逸。这让我想起了初中，想过做网吧老板，想过当乡村杂货铺掌柜，然而当我真正可以决定去做些什么的时候，这一步比设想的要沉重太多。时间推着我们前行，容不得半分迟疑。我们永远不能再走一次时间左侧，有太多的过客经过我们的原点。<br>　　有些人经过我身旁，住在我脑中，在我心里钻洞。有些人变成相片，堆在角落，灰尘像雪一般冰冻。去年的躁动是嫉妒，今年的嫉妒叫压抑。我零零碎碎的尝试用自己半分理智遮掩怪人的负心态，却经常会轻易地让自己压抑的情绪伤害别人。半面是懒惰，半面是高傲，在心底为你们加上莫须有的瑕疵，在纸上划上不能揩平的褶皱，然后心安理得的进入圣人模式。<br>　　今天见了想要见的人，可能没有说话，好的。我骑上车子，在雨中前行代替足球场上的奔跑，雨不大，风也不疾，刚好剪一个清爽的头发，电影片段像头发一样来来回回，最终落在地上，头发还好，所以这个决定应该是对的。每当我逃避显而易见的答案时，总会想方设法寻找一些毫无关联的对象，实现一些其轻而易举可以做到的事情，证明我是对的，现在我希望别人是对的。<br>　　所以我把最善良的我留给今天，​留给2x​，明年来看是经过我身边，还是变成相片。</p>
<p>#人生海海<br><img src="http://7xowaa.com1.z0.glb.clouddn.com/renshenghaihai.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/随笔/">随笔</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-小记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/27/小记/" class="article-date">
  	<time datetime="2014-11-27T06:46:11.000Z" itemprop="datePublished">2014-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/27/小记/">小记(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 　　每当闹事街头，纷纷扰扰的声音聚拢之前，总是习惯性地拿出耳机。我想我非常的习惯音符带给我的安全感。安静，黑暗，每当自己一个人在房间，在椅子上，总会留下最少的光亮，试着用简简单单的本能去聆听世界。<br>    　　但是又不知不觉，在已经过去的1x时代，毫无意义的在其他的小站里，隐藏在华丽的字符间，堆积在藏书纸片中盖起了一座座城堡。每年的这些天，习惯性将自己隐藏在盒子里，营造一种沉闷的氛围。在无人的半夜里哼着歌，在12点钟寂寞的赛道上欢快的奔跑，故意的跌倒，然后下意识的感觉自己心情很好，昨天的昨天，以及那些永远数不完的昨天里，有着数不完的伤心、烦闷，都在站起来的一瞬间遗失在跑道中央。<br>     　　还是说人都会有两面性，就像奴良陆生，像Tamama。在最欢快的时刻总有一瞬间会很平静，你所讨厌的人和事，其实都是你很久的曾经。讨厌浮夸却又害怕自己在这个孤寂星球像蛇一样生存。<br>    　　很喜欢ashin的一句话&lt;衣服晒干，风在穿，心情变的很蔚蓝。 我一个人，很简单，自己放纵自己管。&gt; 也会想要被人理解，却从未想要被人完全了解。应该说都是相对的吧，这世界本来就没有什么是绝对，即使你赤裸裸的站在某个世界中央。楚门的生活充满镜头，而这样的生活，不需要监控，因为它时时刻刻在你的身体里，血液中。世界的乐趣就在于你永远不知道除了你之外的事物，因为我们不可能认清这一切。<br>    　　这将会是怎样的开始呢，在凌晨的寒风中感受世界，试图从风中触碰到这方天地给我的反馈。奔跑、喊着，会怎样怎样，才发现人生真的不都像是剧本，小时候，you are  the king of the world，整个世界都是为你存在，而现在，应该清楚，世界给了我们十多年的假象，感谢这个世界让我们都天真过。<br>    　　在这个大地上生活的20000多天里，每一天都有你不知道事情发生。未来会怎样？会在你手表秒针一次次的走动间清晰。而我们要做的，就是让这只表一步步，一分分，走下去。</p>
<p>#我要去哪里<br><img src="http://7xowaa.com1.z0.glb.clouddn.com/asinecat.jpg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/随笔/">随笔</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 培豪
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>